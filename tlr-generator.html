<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TLR Audio Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-style: italic;
        }
        .section {
            margin: 25px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background: #3498db;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            transition: background-color 0.3s;
        }
        .file-input-wrapper:hover { background: #2980b9; }
        .file-input-wrapper input[type=file] {
            position: absolute; left: -9999px;
        }
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        input[type="number"], input[type="range"], select {
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 4px;
            font-size: 16px;
        }
        input[type="range"] { padding: 0; }
        .range-value {
            font-weight: bold;
            color: #3498db;
            text-align: center;
            margin-top: 5px;
        }
        button {
            background: #27ae60;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 10px 5px;
        }
        button:hover { background: #229954; }
        button:disabled { background: #95a5a6; cursor: not-allowed; }
        .progress-container { margin: 20px 0; display: none; }
        .progress-bar {
            width: 100%; height: 20px; background: #ecf0f1;
            border-radius: 10px; overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%; transition: width 0.3s; border-radius: 10px;
        }
        .status {
            margin: 15px 0; padding: 12px; border-radius: 6px;
            text-align: center; font-weight: 500;
        }
        .status.info { background: #e3f2fd; color: #1976d2; border: 1px solid #bbdefb; }
        .status.success { background: #e8f5e8; color: #2e7d32; border: 1px solid #a5d6a7; }
        .status.error { background: #ffebee; color: #c62828; border: 1px solid #ef9a9a; }
        .file-info {
            background: #e8f4f8; padding: 15px; border-radius: 6px;
            margin: 15px 0; border-left: 4px solid #3498db;
        }
        .protocol-info {
            background: #f0f8ff; padding: 20px; border-radius: 8px;
            margin: 20px 0; border: 2px solid #3498db;
        }
        .protocol-info h3 { color: #2c3e50; margin-top: 0; }
        .protocol-info ul { margin: 10px 0; padding-left: 20px; }
        .protocol-info li { margin: 5px 0; }
        @media (max-width: 600px) {
            .controls { grid-template-columns: 1fr; }
            body { padding: 10px; }
            .container { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ TLR Audio Generator</h1>
        <p class="subtitle">Create Targeted Lucidity Reactivation audio files for lucid dream training</p>

        <div class="protocol-info">
            <h3>üìã About TLR (Targeted Lucidity Reactivation)</h3>
            <p>TLR pairs audio cues with lucid mindset training before sleep, then presents the same cues during sleep to trigger lucidity. <strong>Northwestern University 2024 study showed 3√ó increase in lucid dreams.</strong></p>
            <ul>
                <li><strong>Step 1:</strong> Pre-sleep training (‚âà15‚Äì20 min) - Practice lucid intentions while hearing cues</li>
                <li><strong>Step 2:</strong> Sleep cues (1+ hours, start ~6 h after bedtime) - Same cues trigger memory reactivation during REM</li>
                <li><strong>Workflow:</strong> Training ‚Üí Sleep 6 h ‚Üí Cues during late-night REM ‚Üí Enhanced lucidity</li>
                <li><strong>Key:</strong> Use identical audio cues for both training and sleep phases</li>
                <li><strong>Apps:</strong> Download raw cue files to import into your own timer/alarm apps</li>
            </ul>
        </div>

        <div class="section">
            <h3>üéµ Choose Your Cue Sound</h3>
            
            <div style="margin-bottom: 20px;">
                <div style="margin-bottom: 15px;">
                    <label>
                        <input type="radio" name="soundChoice" value="upload" checked style="margin-right: 8px;">
                        Upload custom file
                    </label>
                    <div id="uploadSection" style="margin: 10px 0 0 26px;">
                        <div class="file-input-wrapper" onclick="document.getElementById('audioFile').click();">
                            <input type="file" id="audioFile" accept=".mp3,.wav,.m4a,.ogg,.flac">
                            <span>Choose Audio File</span>
                        </div>
                    </div>
                </div>

                <div>
                    <label>
                        <input type="radio" name="soundChoice" value="default" style="margin-right: 8px;">
                        Use default sound
                    </label>
                    <div id="defaultSection" style="margin: 10px 0 0 26px; display: none;">
                        <select id="defaultSound" style="padding: 10px; border: 2px solid #bdc3c7; border-radius: 4px; font-size: 16px; margin-right: 10px;">
                            <option value="">Select a sound...</option>
                            <option value="sounds/common-crane.mp3">üê¶ Common Crane</option>
                            <option value="sounds/drums.mp3">ü•Å Drums</option>
                            <option value="sounds/flute.mp3">üéµ Flute</option>
                            <option value="sounds/piano.mp3">üéπ Piano</option>
                        </select>
                        <button id="previewDefaultBtn" onclick="previewDefaultSound()" style="padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            üîä Preview
                        </button>
                    </div>
                </div>
            </div>

            <!-- Optional guidance override -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #bdc3c7;">
                <div class="file-input-wrapper" onclick="document.getElementById('guidanceFile').click();">
                    <input type="file" id="guidanceFile" accept=".mp3,.wav,.m4a,.ogg,.flac">
                    <span>Optional: Override Guidance</span>
                </div>
            </div>

            <div id="fileInfo" class="file-info" style="display: none;"></div>
        </div>

        <div class="section">
            <h3>‚öôÔ∏è Configuration</h3>
            <div class="controls">
                <div class="control-group">
                    <label for="protocolType">TLR Protocol</label>
                    <select id="protocolType" style="padding: 10px; border: 2px solid #bdc3c7; border-radius: 4px; font-size: 16px;">
                        <option value="northwestern">Step 1: Pre-sleep training (15 min)</option>
                        <option value="sleep-cues">Step 2: Sleep cues (1+ hours)</option>
                        <option value="custom">Custom duration</option>
                        <option value="cue-files-only">Cue files only (raw download)</option>
                    </select>
                </div>
                <div class="control-group" id="nwNightModeGroup" style="display: none;">
                    <label for="nwNightMode">Pre-sleep night mode</label>
                    <select id="nwNightMode" style="padding: 10px; border: 2px solid #bdc3c7; border-radius: 4px; font-size: 16px;">
                        <option value="night1">Night 1 (4√ó guidance)</option>
                        <option value="nights2_7">Nights 2‚Äì7 (1√ó guidance)</option>
                        <option value="no_guidance">No guidance (cues only)</option>
                    </select>
                </div>

                <div class="control-group" id="customDuration" style="display: none;">
                    <label for="duration">Session Duration (minutes)</label>
                    <input type="range" id="duration" min="5" max="30" value="15" step="1">
                    <div class="range-value"><span id="durationValue">15</span> minutes</div>
                </div>

                <div class="control-group" id="sleepDuration" style="display: none;">
                    <label for="sleepLength">Sleep Cue Duration (hours)</label>
                    <input type="range" id="sleepLength" min="1" max="4" value="1" step="0.5">
                    <div class="range-value"><span id="sleepLengthValue">1.0</span> hours</div>
                    <div id="timeEstimate" class="time-estimate" style="display: none; margin-top: 8px; padding: 8px 12px; background: #fff3cd; border-left: 4px solid #ff9800; border-radius: 4px; font-size: 0.9em; color: #856404;">
                        ‚è±Ô∏è <span id="estimateText">Estimated generation time: 3-4 minutes</span>
                    </div>
                </div>

                <div class="control-group">
                    <label for="minInterval">Min Interval (seconds)</label>
                    <input type="number" id="minInterval" value="45" min="10" max="120">
                </div>

                <div class="control-group">
                    <label for="maxInterval">Max Interval (seconds)</label>
                    <input type="number" id="maxInterval" value="120" min="15" max="180">
                </div>

                <div class="control-group">
                    <label for="volumeMode">Volume Strategy</label>
                    <select id="volumeMode" style="padding: 10px; border: 2px solid #bdc3c7; border-radius: 4px; font-size: 16px%;">
                        <option value="fixed">Fixed volume</option>
                        <option value="progressive">Progressive (Northwestern style)</option>
                    </select>
                </div>

                <div class="control-group" id="fixedVolumeControl">
                    <label for="volume">Cue Volume</label>
                    <input type="range" id="volume" min="0.1" max="1.0" value="0.7" step="0.1">
                    <div class="range-value"><span id="volumeValue">70</span>%</div>
                </div>

                <div class="control-group" id="progressiveVolumeControl" style="display: none;">
                    <label for="startVolume">Starting Volume</label>
                    <input type="range" id="startVolume" min="0.05" max="0.5" value="0.15" step="0.05">
                    <div class="range-value"><span id="startVolumeValue">15</span>%</div>
                </div>

                <div class="control-group" id="progressiveIncrement" style="display: none;">
                    <label for="volumeIncrement">Volume Increase per Cue</label>
                    <input type="range" id="volumeIncrement" min="0.1" max="1.0" value="0.16" step="0.02">
                    <div class="range-value"><span id="volumeIncrementValue">0.16</span>%</div>
                </div>

                <div class="control-group" id="progressiveMaxVolume" style="display: none;">
                    <label for="maxVolume">Maximum Volume Cap</label>
                    <input type="range" id="maxVolume" min="0.2" max="0.8" value="0.4" step="0.05">
                    <div class="range-value"><span id="maxVolumeValue">40</span>%</div>
                </div>

                <div class="control-group">
                    <label for="format">Output Format</label>
                    <select id="format" style="padding: 10px; border: 2px solid #bdc3c7; border-radius: 4px; font-size: 16px;">
                        <option value="mp3">MP3 (smaller file)</option>
                        <option value="wav">WAV (uncompressed)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="highMemoryMode" style="margin-right: 8px;">
                        High memory mode (faster, requires 4+ GB RAM)
                    </label>
                    <div style="font-size: 0.85em; color: #666; margin-top: 4px; line-height: 1.3;">
                        ‚ö° Faster generation but may fail on long durations or low-memory devices
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <button id="generateBtn" onclick="generateTLRAudio()" disabled>üéµ Generate TLR Audio</button>
            <button id="previewBtn" onclick="previewCue()" disabled>üîä Preview Cue</button>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText" class="status info">Preparing...</div>
        </div>

        <div id="status"></div>
    </div>

    <script>
        let audioBuffer = null;
        let guidanceBuffer = null;
        let audioContext = null;
        let previewSource = null;

        document.getElementById('audioFile').addEventListener('change', handleFileSelect);
        document.getElementById('duration').addEventListener('input', updateDurationDisplay);
        document.getElementById('sleepLength').addEventListener('input', updateSleepLengthDisplay);
        document.getElementById('volume').addEventListener('input', updateVolumeDisplay);
        document.getElementById('minInterval').addEventListener('input', validateIntervals);
        document.getElementById('maxInterval').addEventListener('input', validateIntervals);
        document.getElementById('protocolType').addEventListener('change', updateProtocolSettings);
        document.getElementById('volumeMode').addEventListener('change', updateVolumeMode);
        document.getElementById('startVolume').addEventListener('input', updateStartVolumeDisplay);
        document.getElementById('volumeIncrement').addEventListener('input', updateVolumeIncrementDisplay);
        document.getElementById('maxVolume').addEventListener('input', updateMaxVolumeDisplay);
        document.getElementById('highMemoryMode').addEventListener('change', updateSleepLengthDisplay);
        
        // Handle radio button changes
        document.querySelectorAll('input[name="soundChoice"]').forEach(radio => {
            radio.addEventListener('change', handleSoundChoiceChange);
        });
        document.getElementById('defaultSound').addEventListener('change', handleDefaultSoundChange);

        function handleSoundChoiceChange(event) {
            const uploadSection = document.getElementById('uploadSection');
            const defaultSection = document.getElementById('defaultSection');
            const generateBtn = document.getElementById('generateBtn');
            
            if (event.target.value === 'upload') {
                uploadSection.style.display = 'block';
                defaultSection.style.display = 'none';
                document.getElementById('fileInfo').style.display = audioBuffer ? 'block' : 'none';
                generateBtn.disabled = !audioBuffer;
            } else {
                uploadSection.style.display = 'none';
                defaultSection.style.display = 'block';
                document.getElementById('fileInfo').style.display = 'none';
                const defaultSound = document.getElementById('defaultSound');
                generateBtn.disabled = !defaultSound.value;
            }
        }

        function handleDefaultSoundChange(event) {
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = !event.target.value;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            showStatus('Loading audio file.', 'info');

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    audioBuffer = await audioContext.decodeAudioData(e.target.result);

                    const duration = audioBuffer.duration.toFixed(2);
                    const size = (file.size / 1024 / 1024).toFixed(2);

                    document.getElementById('fileInfo').innerHTML = `
                        <strong>üìÅ ${file.name}</strong><br>
                        Duration: ${duration}s | Size: ${size}MB | Sample Rate: ${audioBuffer.sampleRate}Hz
                    `;
                    document.getElementById('fileInfo').style.display = 'block';
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('previewBtn').disabled = false;

                    showStatus('‚úÖ Audio file loaded successfully!', 'success');
                } catch (error) {
                    showStatus('‚ùå Error loading audio file: ' + error.message, 'error');
                    console.error('Audio decode error:', error);
                }
            };

            reader.onerror = function() {
                showStatus('‚ùå Error reading file', 'error');
            };

            reader.readAsArrayBuffer(file);
        }

        function updateDurationDisplay() {
            const duration = document.getElementById('duration').value;
            document.getElementById('durationValue').textContent = parseInt(duration);
        }

        function updateSleepLengthDisplay() {
            const sleepLength = parseFloat(document.getElementById('sleepLength').value);
            document.getElementById('sleepLengthValue').textContent = sleepLength.toFixed(1);
            
            // Show time estimate for longer durations
            const timeEstimate = document.getElementById('timeEstimate');
            const estimateText = document.getElementById('estimateText');
            
            if (sleepLength >= 1.0) {
                const highMemoryMode = document.getElementById('highMemoryMode').checked;
                let minutes, minTime, maxTime;
                
                if (highMemoryMode) {
                    // High memory mode: much faster
                    minutes = Math.round(sleepLength * 0.5); // ~0.5 min per hour
                    minTime = Math.max(1, Math.round(minutes * 0.8));
                    maxTime = Math.round(minutes * 1.2);
                    estimateText.textContent = `Estimated generation time: ${minTime}-${maxTime} minutes (high memory)`;
                } else {
                    // Chunked mode: slower but memory safe
                    minutes = Math.round(sleepLength * 1.5); // ~1.5 min per hour
                    minTime = Math.max(2, minutes - 1);
                    maxTime = minutes + 1;
                    estimateText.textContent = `Estimated generation time: ${minTime}-${maxTime} minutes`;
                }
                
                timeEstimate.style.display = 'block';
            } else {
                timeEstimate.style.display = 'none';
            }
        }

        function updateVolumeDisplay() {
            const volume = document.getElementById('volume').value;
            document.getElementById('volumeValue').textContent = Math.round(volume * 100);
        }

        function validateIntervals() {
            const minInterval = parseInt(document.getElementById('minInterval').value);
            const maxInterval = parseInt(document.getElementById('maxInterval').value);
            if (minInterval >= maxInterval) {
                document.getElementById('maxInterval').value = minInterval + 5;
            }
        }

        function updateProtocolSettings() {
            const protocolType = document.getElementById('protocolType').value;
            const customDuration = document.getElementById('customDuration');
            const sleepDuration = document.getElementById('sleepDuration');
            const nwNightModeGroup = document.getElementById('nwNightModeGroup');
            const generateBtn = document.getElementById('generateBtn');
            const timingControls = ['minInterval', 'maxInterval', 'volumeMode', 'fixedVolumeControl', 'progressiveVolumeControl', 'progressiveIncrement', 'progressiveMaxVolume'];
            
            // Hide all dynamic controls first
            customDuration.style.display = 'none';
            sleepDuration.style.display = 'none';
            document.getElementById('timeEstimate').style.display = 'none';
            if (nwNightModeGroup) nwNightModeGroup.style.display = 'none';
            
            if (protocolType === 'cue-files-only') {
                // Hide timing controls for raw download - but keep protocol selector visible
                timingControls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        const parentGroup = element.closest('.control-group');
                        if (parentGroup) parentGroup.style.visibility = 'hidden';
                    }
                });
                generateBtn.textContent = 'üì• Download Cue File';
            } else {
                // Show timing controls for processed audio
                timingControls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        const parentGroup = element.closest('.control-group');
                        if (parentGroup) parentGroup.style.visibility = 'visible';
                    }
                });
                generateBtn.textContent = 'üéµ Generate TLR Audio';
                
                if (protocolType === 'northwestern') {
                    if (nwNightModeGroup) nwNightModeGroup.style.display = 'block';
                    // Northwestern pre-sleep training defaults
                    document.getElementById('minInterval').value = 45;
                    document.getElementById('maxInterval').value = 120;
                    document.getElementById('volumeMode').value = 'progressive';
                    updateVolumeMode();
                } else if (protocolType === 'sleep-cues') {
                    // Sleep-time cue protocol
                    sleepDuration.style.display = 'block';
                    updateSleepLengthDisplay(); // Show time estimate if needed
                    document.getElementById('minInterval').value = 20;
                    document.getElementById('maxInterval').value = 40;
                    document.getElementById('volumeMode').value = 'progressive';
                    updateVolumeMode();
                } else {
                    // Custom protocol
                    customDuration.style.display = 'block';
                    document.getElementById('minInterval').value = 20;
                    document.getElementById('maxInterval').value = 60;
                }
            }
        }

        function updateVolumeMode() {
            const volumeMode = document.getElementById('volumeMode').value;
            const fixedVolumeControl = document.getElementById('fixedVolumeControl');
            const progressiveVolumeControl = document.getElementById('progressiveVolumeControl');
            const progressiveIncrement = document.getElementById('progressiveIncrement');
            const progressiveMaxVolume = document.getElementById('progressiveMaxVolume');
            
            if (volumeMode === 'progressive') {
                fixedVolumeControl.style.display = 'none';
                progressiveVolumeControl.style.display = 'block';
                progressiveIncrement.style.display = 'block';
                progressiveMaxVolume.style.display = 'block';
            } else {
                fixedVolumeControl.style.display = 'block';
                progressiveVolumeControl.style.display = 'none';
                progressiveIncrement.style.display = 'none';
                progressiveMaxVolume.style.display = 'none';
            }
        }

        function updateStartVolumeDisplay() {
            const startVolume = document.getElementById('startVolume').value;
            document.getElementById('startVolumeValue').textContent = Math.round(startVolume * 100);
        }
        function updateVolumeIncrementDisplay() {
            const increment = document.getElementById('volumeIncrement').value;
            document.getElementById('volumeIncrementValue').textContent = parseFloat(increment).toFixed(2);
        }
        function updateMaxVolumeDisplay() {
            const maxVolume = document.getElementById('maxVolume').value;
            document.getElementById('maxVolumeValue').textContent = Math.round(maxVolume * 100);
        }

        function previewCue() {
            if (!audioContext || !audioBuffer) return;
            if (previewSource) previewSource.stop();

            const volume = parseFloat(document.getElementById('volume').value);

            previewSource = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            previewSource.buffer = audioBuffer;
            gainNode.gain.value = volume;

            previewSource.connect(gainNode);
            gainNode.connect(audioContext.destination);

            previewSource.start(0);

            showStatus('üîä Playing preview.', 'info');
            setTimeout(() => { showStatus('Preview complete', 'info'); }, Math.min(audioBuffer.duration * 1000, 3000));
        }

        async function previewDefaultSound() {
            const selectedSound = document.getElementById('defaultSound').value;
            if (!selectedSound) return;

            if (previewSource) previewSource.stop();

            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                showStatus('Loading preview...', 'info');

                const response = await fetch(selectedSound);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                const volume = parseFloat(document.getElementById('volume').value);

                previewSource = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();

                previewSource.buffer = audioBuffer;
                gainNode.gain.value = volume;

                previewSource.connect(gainNode);
                gainNode.connect(audioContext.destination);

                previewSource.start(0);

                showStatus('üîä Playing preview.', 'info');
                setTimeout(() => { showStatus('Preview complete', 'info'); }, Math.min(audioBuffer.duration * 1000, 3000));

            } catch (error) {
                console.error('Preview error:', error);
                showStatus('Failed to preview sound', 'error');
            }
        }

        // Guidance loader: override file or defaults from /audio directory
        async function getGuidanceBuffer() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const override = document.getElementById('guidanceFile');
            if (override && override.files && override.files[0]) {
                const arr = await override.files[0].arrayBuffer();
                return audioContext.decodeAudioData(arr);
            }
            const candidates = ['audio/guidance_en.mp3', 'audio/guidance_et.mp3'];
            for (const url of candidates) {
                try {
                    const resp = await fetch(url);
                    if (!resp.ok) continue;
                    const arr = await resp.arrayBuffer();
                    return await audioContext.decodeAudioData(arr);
                } catch (e) {
                    // try next
                }
            }
            throw new Error('Guidance audio not found. Add audio/guidance_en.mp3 or audio/guidance_et.mp3, or use the override input.');
        }

        async function generateTLRAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Get the current sound choice and load appropriate audio
            const soundChoice = document.querySelector('input[name="soundChoice"]:checked').value;
            let currentAudioBuffer = null;

            if (soundChoice === 'upload') {
                if (!audioBuffer) {
                    showStatus('Please select an audio file first', 'error');
                    return;
                }
                currentAudioBuffer = audioBuffer;
            } else {
                const selectedDefaultSound = document.getElementById('defaultSound').value;
                if (!selectedDefaultSound) {
                    showStatus('Please select a default sound first', 'error');
                    return;
                }

                try {
                    showStatus('Loading default sound...', 'info');
                    const response = await fetch(selectedDefaultSound);
                    const arrayBuffer = await response.arrayBuffer();
                    currentAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                } catch (error) {
                    console.error('Error loading default sound:', error);
                    showStatus('Failed to load default sound', 'error');
                    return;
                }
            }

            const protocolType = document.getElementById('protocolType').value;
            
            // Handle cue-files-only: direct download of raw audio
            if (protocolType === 'cue-files-only') {
                try {
                    showProgress(0, 'Preparing raw cue file...');
                    
                    const format = document.getElementById('format').value;
                    let finalBlob, filename;
                    
                    if (soundChoice === 'upload') {
                        // Use original uploaded file
                        const file = document.getElementById('audioFile').files[0];
                        finalBlob = file;
                        const baseName = file.name.split('.')[0];
                        filename = `TLR-Cue-${baseName}.${format}`;
                    } else {
                        // Convert default sound to desired format
                        const sampleRate = currentAudioBuffer.sampleRate;
                        const channels = currentAudioBuffer.numberOfChannels;
                        const length = currentAudioBuffer.length;
                        const audioData = new Float32Array(length * channels);
                        
                        for (let channel = 0; channel < channels; channel++) {
                            const channelData = currentAudioBuffer.getChannelData(channel);
                            for (let i = 0; i < length; i++) {
                                audioData[i * channels + channel] = channelData[i];
                            }
                        }
                        
                        showProgress(50, `Encoding ${format.toUpperCase()}...`);
                        
                        const soundName = document.getElementById('defaultSound').selectedOptions[0].text.replace(/[^\w\s-]/g, '').replace(/\s+/g, '-');
                        
                        if (format === 'mp3') {
                            finalBlob = await encodeMP3(audioData, sampleRate);
                            filename = `TLR-Cue-${soundName}.mp3`;
                        } else {
                            const wavBuffer = float32ArrayToWav(audioData, sampleRate);
                            finalBlob = new Blob([wavBuffer], { type: 'audio/wav' });
                            filename = `TLR-Cue-${soundName}.wav`;
                        }
                    }
                    
                    showProgress(95, 'Preparing download...');
                    const url = URL.createObjectURL(finalBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showProgress(100, 'Complete!');
                    showStatus(`‚úÖ Raw cue file downloaded: ${filename}`, 'success');
                    
                    setTimeout(() => {
                        document.getElementById('progressContainer').style.display = 'none';
                    }, 3000);
                    
                    return;
                } catch (error) {
                    showStatus('‚ùå Error downloading cue file: ' + error.message, 'error');
                    document.getElementById('progressContainer').style.display = 'none';
                    return;
                }
            }
            const minInterval = parseInt(document.getElementById('minInterval').value);
            const maxInterval = parseInt(document.getElementById('maxInterval').value);
            const volumeMode = document.getElementById('volumeMode').value;

            // Volume settings
            let volume, startVolume, volumeIncrement, maxVolume;
            if (volumeMode === 'progressive') {
                startVolume = parseFloat(document.getElementById('startVolume').value);
                volumeIncrement = parseFloat(document.getElementById('volumeIncrement').value) / 100; // % -> decimal (linear step, unchanged)
                maxVolume = parseFloat(document.getElementById('maxVolume').value);
            } else {
                volume = parseFloat(document.getElementById('volume').value);
            }

            try {
                showProgress(0, 'Calculating cue placements...');
                await new Promise(resolve => setTimeout(resolve, 50));

                let cueTimes = [];
                let guidanceTimes = [];
                let duration;
                
                if (protocolType === 'northwestern') {
                    // Pre-sleep training schedule
                    const nightModeEl = document.getElementById('nwNightMode');
                    const mode = nightModeEl ? nightModeEl.value : 'night1';
                    
                    if (mode === 'no_guidance') {
                        // No guidance mode: just cues with standard intervals
                        const PRACTICE = [45, 70, 55, 65, 70, 80, 65, 60, 75, 75, 90, 120];
                        const sr = audioContext.sampleRate;
                        const cueDurSec = currentAudioBuffer.length / sr;
                        const MAX_DURATION = 15 * 60; // 15 minutes cap
                        
                        let t = 0;
                        for (const gap of PRACTICE) {
                            // Check if adding this cue would exceed 15 minutes
                            if (t > MAX_DURATION) break;
                            
                            cueTimes.push(t);
                            t += cueDurSec + gap; // cue duration + interval
                        }
                        
                        // Duration is either 15 minutes or time for final cue to complete
                        const finalCueEnd = cueTimes.length > 0 ? cueTimes[cueTimes.length - 1] + cueDurSec : 0;
                        duration = Math.max(MAX_DURATION, finalCueEnd);
                    } else {
                        // Standard guided modes
                        guidanceBuffer = await getGuidanceBuffer();
                        
                        const PRACTICE = [45, 70, 55, 65, 70, 80, 65, 60, 75, 75, 90, 120];
                        const GUIDED_REPS = (mode === 'nights2_7') ? 1 : 4;
                        const sr = audioContext.sampleRate;
                        const cueDurSec = currentAudioBuffer.length / sr;
                        const guidDurSec = guidanceBuffer.length / sr;
                        
                        let t = 0;
                        // Guided cycles: cue ‚Üí guidance ‚Üí 45 s pause
                        for (let i = 0; i < GUIDED_REPS; i++) {
                            cueTimes.push(t);
                            const gStart = t + cueDurSec + 0.05; // guidance starts 50 ms after cue
                            guidanceTimes.push(gStart);
                            t = gStart + guidDurSec + 45;
                        }
                        // Practice cues: 12 fixed intervals
                        const MAX_DURATION = 15 * 60; // 15 minutes cap
                        for (const gap of PRACTICE) {
                            // Check if adding this cue would exceed 15 minutes
                            if (t > MAX_DURATION) break;
                            
                            cueTimes.push(t);
                            t += cueDurSec + gap; // cue duration + interval
                        }
                        
                        // Duration is either 15 minutes or time for final cue to complete
                        const finalCueEnd = cueTimes.length > 0 ? cueTimes[cueTimes.length - 1] + cueDurSec : t;
                        duration = Math.max(MAX_DURATION, finalCueEnd);
                    }
                } else if (protocolType === 'sleep-cues') {
                    // Sleep-time cues: random spacing (default 20‚Äì40 s), for N hours
                    duration = parseFloat(document.getElementById('sleepLength').value) * 3600;
                    const sr = audioContext.sampleRate;
                    const cueDurSec = currentAudioBuffer.length / sr;
                    
                    let currentTime = Math.random() * (maxInterval - minInterval) + minInterval;
                    while (currentTime < duration) {
                        cueTimes.push(currentTime);
                        const interval = Math.random() * (maxInterval - minInterval) + minInterval;
                        currentTime += cueDurSec + interval; // cue duration + interval
                    }
                } else {
                    // Custom protocol
                    duration = parseFloat(document.getElementById('duration').value) * 60;
                    const sr = audioContext.sampleRate;
                    const cueDurSec = currentAudioBuffer.length / sr;
                    
                    let currentTime = Math.random() * (maxInterval - minInterval) + minInterval;
                    while (currentTime < duration) {
                        cueTimes.push(currentTime);
                        const interval = Math.random() * (maxInterval - minInterval) + minInterval;
                        currentTime += cueDurSec + interval; // cue duration + interval
                    }
                }
                
                showProgress(10, `Generating ${cueTimes.length} cues in chunks...`);
                
                // Use chunked processing to avoid memory issues
                const sampleRate = (audioContext && audioContext.sampleRate) ? audioContext.sampleRate : 48000; // use context rate
                const chunkDuration = 300; // 5 minutes per chunk
                const chunkSamples = chunkDuration * sampleRate;
                const totalChunks = Math.ceil(duration / chunkDuration);
                
                const wavChunks = [];
                
                for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                    const chunkStart = chunkIndex * chunkDuration;
                    const chunkEnd = Math.min((chunkIndex + 1) * chunkDuration, duration);
                    const actualChunkSamples = Math.floor((chunkEnd - chunkStart) * sampleRate);
                    
                    // Update progress and yield to browser
                    const progress = 10 + (chunkIndex / totalChunks) * 70;
                    showProgress(progress, `Processing chunk ${chunkIndex + 1}/${totalChunks}...`);
                    await new Promise(resolve => setTimeout(resolve, 10)); // Give browser time to update
                    
                    // Create chunk buffer
                    const chunkBuffer = new Float32Array(actualChunkSamples * 2); // Stereo
                    
                    // Find cues in this chunk
                    const chunkCues = cueTimes.filter(time => time >= chunkStart && time < chunkEnd);
                    
                    for (const cueTime of chunkCues) {
                        const sampleOffset = Math.floor((cueTime - chunkStart) * sampleRate);
                        
                        // Determine volume for the cue
                        let cueVolume;
                        if (volumeMode === 'progressive') {
                            const cueIndex = cueTimes.indexOf(cueTime); // keep original behavior
                            cueVolume = Math.min(maxVolume, startVolume + (cueIndex * volumeIncrement));
                        } else {
                            cueVolume = volume;
                        }
                        
                        // Mix in the cue sound with fade in/out for smoother experience
                        const fadeSamples = Math.min(1000, currentAudioBuffer.length); // ~20ms at 48kHz
                        
                        for (let i = 0; i < currentAudioBuffer.length && (sampleOffset + i) < actualChunkSamples; i++) {
                            // Calculate fade multiplier
                            let fadeMultiplier = 1.0;
                            if (i < fadeSamples) {
                                fadeMultiplier = i / fadeSamples; // Fade in
                            } else if (i > currentAudioBuffer.length - fadeSamples) {
                                fadeMultiplier = (currentAudioBuffer.length - i) / fadeSamples; // Fade out
                            }
                            
                            const left = currentAudioBuffer.getChannelData(0)[i] * cueVolume * fadeMultiplier;
                            const right = currentAudioBuffer.numberOfChannels > 1 ? 
                                         currentAudioBuffer.getChannelData(1)[i] * cueVolume * fadeMultiplier : left;
                            
                            chunkBuffer[(sampleOffset + i) * 2] += left;     // Left channel
                            chunkBuffer[(sampleOffset + i) * 2 + 1] += right; // Right channel
                        }
                    }

                    // Mix guidance (only for Step 1 / pre-sleep)
                    if (protocolType === 'northwestern' && guidanceBuffer && guidanceTimes.length) {
                        const guidanceGain = 0.7; // gentle level
                        const gChunk = guidanceTimes.filter(time => time >= chunkStart && time < chunkEnd);
                        const gFadeIn = Math.max(1, Math.floor(0.010 * sampleRate));  // 10ms
                        const gFadeOut = Math.max(1, Math.floor(0.050 * sampleRate)); // 50ms
                        for (const gTime of gChunk) {
                            const gOffset = Math.floor((gTime - chunkStart) * sampleRate);
                            for (let i = 0; i < guidanceBuffer.length && (gOffset + i) < actualChunkSamples; i++) {
                                const rem = guidanceBuffer.length - i;
                                let fade = 1.0;
                                if (i < gFadeIn) fade = i / gFadeIn;
                                if (rem < gFadeOut) fade = Math.min(fade, rem / gFadeOut);
                                const l = guidanceBuffer.getChannelData(0)[i] * guidanceGain * fade;
                                const r = (guidanceBuffer.numberOfChannels > 1 ? guidanceBuffer.getChannelData(1)[i] : l);
                                chunkBuffer[(gOffset + i) * 2] += l;
                                chunkBuffer[(gOffset + i) * 2 + 1] += r;
                            }
                        }
                    }
                    
                    // Store chunk as Float32Array for processing
                    wavChunks.push(chunkBuffer);
                }
                
                const format = document.getElementById('format').value;
                const highMemoryMode = document.getElementById('highMemoryMode').checked;
                let finalBlob, filename;

                let filenamePrefix;
                if (protocolType === 'northwestern') {
                    const nightMode = document.getElementById('nwNightMode').value;
                    const suffix = nightMode === 'no_guidance' ? 'NoGuidance' : 'Training';
                    filenamePrefix = `TLR-Step1-${suffix}-${cueTimes.length}cues`;
                } else if (protocolType === 'sleep-cues') {
                    filenamePrefix = `TLR-Step2-Sleep-${(duration/3600).toFixed(1)}h-${cueTimes.length}cues`;
                } else {
                    filenamePrefix = `TLR-Custom-${(duration/60)}min-${cueTimes.length}cues`;
                }

                if (highMemoryMode) {
                    // High memory mode: faster but uses more RAM
                    showProgress(80, 'Combining chunks (high memory mode)...');
                    
                    const totalSamples = Math.floor(duration * sampleRate);
                    const finalAudioData = new Float32Array(totalSamples * 2); // Stereo
                    let sampleOffset = 0;
                    
                    for (const chunkData of wavChunks) {
                        const chunkLength = Math.min(chunkData.length, finalAudioData.length - sampleOffset);
                        finalAudioData.set(chunkData.subarray(0, chunkLength), sampleOffset);
                        sampleOffset += chunkLength;
                    }

                    if (format === 'mp3') {
                        showProgress(85, 'Encoding MP3...');
                        finalBlob = await encodeMP3(finalAudioData, sampleRate);
                        filename = `${filenamePrefix}.mp3`;
                    } else {
                        showProgress(85, 'Encoding WAV...');
                        const wavBuffer = float32ArrayToWav(finalAudioData, sampleRate);
                        finalBlob = new Blob([wavBuffer], { type: 'audio/wav' });
                        filename = `${filenamePrefix}.wav`;
                    }
                } else {
                    // Chunked mode: slower but memory safe
                    showProgress(80, 'Encoding audio (memory safe mode)...');
                    
                    if (format === 'mp3') {
                        showProgress(85, 'Encoding MP3...');
                        finalBlob = await encodeMP3Chunked(wavChunks, sampleRate);
                        filename = `${filenamePrefix}.mp3`;
                    } else {
                        showProgress(85, 'Encoding WAV...');
                        finalBlob = await encodeWavChunked(wavChunks, sampleRate, duration);
                        filename = `${filenamePrefix}.wav`;
                    }
                }

                showProgress(95, 'Preparing download...');
                const url = URL.createObjectURL(finalBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showProgress(100, 'Complete!');
                let durationText = (protocolType === 'sleep-cues') ? `${(duration/3600).toFixed(1)} hours` : `${Math.round(duration/60)} minutes`;
                showStatus(`‚úÖ TLR audio generated successfully! ${cueTimes.length} cues placed over ${durationText}.`, 'success');
                
                setTimeout(() => {
                    document.getElementById('progressContainer').style.display = 'none';
                }, 3000);
                
            } catch (error) {
                showStatus('‚ùå Error generating audio: ' + error.message, 'error');
                console.error('Generation error:', error);
                document.getElementById('progressContainer').style.display = 'none';
            }
        }

        function float32ArrayToWav(samples, sampleRate) {
            const length = samples.length / 2; // Stereo samples
            const arrayBuffer = new ArrayBuffer(44 + length * 2 * 2); // 2 channels * 2 bytes per sample
            const view = new DataView(arrayBuffer);

            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + length * 2 * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 2, true); // Stereo
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2 * 2, true);
            view.setUint16(32, 4, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, length * 2 * 2, true);

            // Audio data
            let offset = 44;
            for (let i = 0; i < samples.length; i += 2) {
                const left = Math.max(-1, Math.min(1, samples[i]));
                const right = Math.max(-1, Math.min(1, samples[i + 1]));
                view.setInt16(offset, left * 0x7FFF, true);
                view.setInt16(offset + 2, right * 0x7FFF, true);
                offset += 4;
            }

            return arrayBuffer;
        }

        async function encodeMP3(audioData, sampleRate) {
            const mp3encoder = new lamejs.Mp3Encoder(2, sampleRate, 128); // Stereo, sample rate, bitrate
            const mp3Data = [];
            
            const blockSize = 1152; // MP3 frame size
            const totalBlocks = Math.ceil(audioData.length / (blockSize * 2));
            let blockIndex = 0;
            
            for (let i = 0; i < audioData.length; i += blockSize * 2) {
                if (blockIndex % 100 === 0) {
                    const progress = 85 + (blockIndex / totalBlocks) * 10;
                    showProgress(progress, `Encoding MP3... ${Math.round(blockIndex / totalBlocks * 100)}%`);
                    await new Promise(resolve => setTimeout(resolve, 1)); // Yield
                }

                const leftChannel = [];
                const rightChannel = [];
                for (let j = 0; j < blockSize && (i + j * 2) < audioData.length; j++) {
                    leftChannel[j] = Math.round(audioData[i + j * 2] * 32767);
                    rightChannel[j] = Math.round(audioData[i + j * 2 + 1] * 32767);
                }

                const mp3buf = mp3encoder.encodeBuffer(leftChannel, rightChannel);
                if (mp3buf.length > 0) {
                    mp3Data.push(mp3buf);
                }
                
                blockIndex++;
            }
            
            // Flush encoder
            const finalMp3buf = mp3encoder.flush();
            if (finalMp3buf.length > 0) {
                mp3Data.push(finalMp3buf);
            }
            
            return new Blob(mp3Data, { type: 'audio/mp3' });
        }

        async function encodeMP3Chunked(wavChunks, sampleRate) {
            const mp3encoder = new lamejs.Mp3Encoder(2, sampleRate, 128);
            const mp3Data = [];
            const blockSize = 1152;
            
            let totalBlocks = 0;
            for (const chunk of wavChunks) {
                totalBlocks += Math.ceil(chunk.length / (blockSize * 2));
            }
            
            let processedBlocks = 0;
            
            for (const chunk of wavChunks) {
                for (let i = 0; i < chunk.length; i += blockSize * 2) {
                    if (processedBlocks % 100 === 0) {
                        const progress = 85 + (processedBlocks / totalBlocks) * 10;
                        showProgress(progress, `Encoding MP3... ${Math.round(progress)}%`);
                        await new Promise(resolve => setTimeout(resolve, 0)); // Allow UI updates
                    }
                    
                    const leftChannel = [];
                    const rightChannel = [];
                    for (let j = 0; j < blockSize && (i + j * 2) < chunk.length; j++) {
                        leftChannel[j] = Math.round(chunk[i + j * 2] * 32767);
                        rightChannel[j] = Math.round(chunk[i + j * 2 + 1] * 32767);
                    }
                    
                    const mp3buf = mp3encoder.encodeBuffer(leftChannel, rightChannel);
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                    }
                    
                    processedBlocks++;
                }
            }
            
            const finalMp3buf = mp3encoder.flush();
            if (finalMp3buf.length > 0) {
                mp3Data.push(finalMp3buf);
            }
            
            return new Blob(mp3Data, { type: 'audio/mp3' });
        }

        async function encodeWavChunked(wavChunks, sampleRate, duration) {
            // Calculate total length for WAV header
            let totalSamples = 0;
            for (const chunk of wavChunks) {
                totalSamples += chunk.length;
            }
            
            const totalBytes = totalSamples * 2; // 16-bit samples
            const arrayBuffer = new ArrayBuffer(44 + totalBytes);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + totalBytes, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 2, true); // Stereo
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 4, true);
            view.setUint16(32, 4, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, totalBytes, true);
            
            // Write audio data chunk by chunk
            let offset = 44;
            let chunkIndex = 0;
            
            for (const chunk of wavChunks) {
                if (chunkIndex % 10 === 0) {
                    const progress = 85 + (chunkIndex / wavChunks.length) * 10;
                    showProgress(progress, `Encoding WAV... ${Math.round(progress)}%`);
                    await new Promise(resolve => setTimeout(resolve, 0)); // Allow UI updates
                }
                
                for (let i = 0; i < chunk.length; i += 2) {
                    const left = Math.max(-1, Math.min(1, chunk[i]));
                    const right = Math.max(-1, Math.min(1, chunk[i + 1]));
                    view.setInt16(offset, left * 32767, true);
                    view.setInt16(offset + 2, right * 32767, true);
                    offset += 4;
                }
                
                chunkIndex++;
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function showProgress(percent, message) {
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = message;
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }

        // Initialize
        updateProtocolSettings();
        updateDurationDisplay();
        updateSleepLengthDisplay();
        updateVolumeDisplay();
        updateStartVolumeDisplay();
        updateVolumeIncrementDisplay();
        updateMaxVolumeDisplay();
        updateVolumeMode();
    </script>
</body>
</html>
